//! Contains the code for the "special library", i.e. the hardcoded families of
//! polytopes in the Miratope library.

use egui::Ui;
use serde::{Deserialize, Serialize};

use crate::Concrete;
use miratope_core::conc::ConcretePolytope;
use miratope_core::Polytope;

use super::ShowResult;

/// Represents any of the special polytopes in Miratope's library, namely those
/// families that are generated by code.
///
/// The variants of the special library store whatever value is currently being
/// stored on screen. When the user clicks on the button to load them, they're
/// sent together with their values as a [`ShowResult`] to the [`show_library`]
/// system, which then actually loads the polytope.
#[derive(Clone, Copy, Serialize, Deserialize, Debug)]
pub enum SpecialLibrary {
    /// A regular polygon.
    Polygon(usize, usize),

    /// A (uniform 3D) prism.
    Prism(usize, usize),

    /// A (uniform 3D) antiprism.
    Antiprism(usize, usize),

    /// A (4D uniform) duoprism.
    Duoprism(usize, usize, usize, usize),

    /// A (4D uniform) antiprismatic prism.
    AntiprismPrism(usize, usize),

    /// A simplex.
    Simplex(isize),

    /// A hypercube.
    Hypercube(isize),

    /// An orthoplex.
    Orthoplex(isize),
}

impl SpecialLibrary {
    /// Returns the label for a given entry in the special library.
    pub fn label(&self) -> &'static str {
        match self {
            Self::Polygon(_, _) => "Polygon",
            Self::Prism(_, _) => "Prism",
            Self::Antiprism(_, _) => "Antiprism",
            Self::Duoprism(_, _, _, _) => "Duoprism",
            Self::AntiprismPrism(_, _) => "Antiprism prism",
            Self::Simplex(_) => "Simplex",
            Self::Hypercube(_) => "Hypercube",
            Self::Orthoplex(_) => "Orthoplex",
        }
    }

    /// Shows the special component of the library. Returns the action selected
    /// by the user, if any.
    pub fn show(&mut self, ui: &mut Ui) -> ShowResult {
        let text = self.label();

        match self {
            // An {n / d} regular polygon or uniform polygonal prism.
            Self::Polygon(n, d) | Self::Prism(n, d) => {
                let mut clicked = false;

                ui.horizontal(|ui| {
                    clicked = ui.button(text).clicked();

                    // Number of sides.
                    ui.label("n:");
                    ui.add(
                        egui::DragValue::new(n)
                            .speed(0.03)
                            .clamp_range(2..=usize::MAX),
                    );

                    // Turning number.
                    let max_n = *n / 2;
                    ui.label("d:");
                    ui.add(egui::DragValue::new(d).speed(0.03).clamp_range(1..=max_n));
                });

                if clicked {
                    ShowResult::Special(*self)
                } else {
                    ShowResult::None
                }
            }

            // An {n / d} uniform antiprism.
            Self::Antiprism(n, d) | Self::AntiprismPrism(n, d) => {
                let clicked = ui.horizontal(|ui| {
                    let clicked = ui.button(text).clicked();

                    // Number of sides.
                    ui.label("n:");
                    ui.add(
                        egui::DragValue::new(n)
                            .speed(0.03)
                            .clamp_range(2..=usize::MAX),
                    );

                    // Turning number.
                    let max_n = *n * 2 / 3;
                    ui.label("d:");
                    ui.add(egui::DragValue::new(d).speed(0.03).clamp_range(1..=max_n));

                    clicked
                });

                if clicked.inner {
                    ShowResult::Special(*self)
                } else {
                    ShowResult::None
                }
            }

            // A uniform duoprism based on two polygons.
            Self::Duoprism(n1, d1, n2, d2) => {
                let clicked = ui.horizontal_wrapped(|ui| {
                    let clicked = ui.button(text).clicked();

                    // Number of sides.
                    ui.label("n₁:");
                    ui.add(
                        egui::DragValue::new(n1)
                            .speed(0.03)
                            .clamp_range(2..=usize::MAX),
                    );

                    // Turning number.
                    let max_n1 = *n1 / 2;
                    ui.label("d₁:");
                    ui.add(egui::DragValue::new(d1).speed(0.03).clamp_range(1..=max_n1));

                    // Number of sides.
                    ui.label("n₂:");
                    ui.add(
                        egui::DragValue::new(n2)
                            .speed(0.03)
                            .clamp_range(2..=usize::MAX),
                    );

                    // Turning number.
                    let max_n2 = *n2 / 2;
                    ui.label("d₂:");
                    ui.add(egui::DragValue::new(d2).speed(0.03).clamp_range(1..=max_n2));

                    clicked
                });

                if clicked.inner {
                    ShowResult::Special(*self)
                } else {
                    ShowResult::None
                }
            }

            // A simplex, hypercube, or orthoplex of a given rank.
            Self::Simplex(rank) | Self::Hypercube(rank) | Self::Orthoplex(rank) => {
                let clicked = ui.horizontal(|ui| {
                    let clicked = ui.button(text).clicked();

                    ui.label("Rank:");
                    ui.add(egui::DragValue::new(rank).speed(0.03).clamp_range(-1..=20));

                    clicked
                });

                if clicked.inner {
                    ShowResult::Special(*self)
                } else {
                    ShowResult::None
                }
            }
        }
    }

    /// Loads the given special polytope from the library.
    pub fn load(&self) -> (Concrete, String) {
        match *self {
            // Loads a regular star polygon.
            Self::Polygon(n, d) => (
                Concrete::star_polygon_with_edge(n, d, 1.0),
                format!(
                    "{}{}-gon",
                    n,
                    if d > 1 {format!("/{}", d)} else {"".to_string()}
                )
            ),

            // Loads a uniform polygonal prism.
            Self::Prism(n, d) => (
                Concrete::uniform_prism(n, d),
                format!(
                    "{}{}-gonal prism",
                    n,
                    if d > 1 {format!("/{}", d)} else {"".to_string()}
                )
            ),

            // Loads a uniform polygonal antiprism.
            Self::Antiprism(n, d) => (
                Concrete::uniform_antiprism(n, d),
                format!(
                    "{}{}-gonal antiprism",
                    n,
                    if d > 1 {format!("/{}", d)} else {"".to_string()}
                )
            ),

            // Loads a uniform polygonal duoprism.
            Self::Duoprism(n1, d1, n2, d2) => (
                {
                    let p1 = Concrete::star_polygon_with_edge(n1, d1, 1.0);

                    // Avoids duplicate work if possible.
                    if n1 == n2 && d1 == d2 {
                        Concrete::duoprism(&p1, &p1)
                    } else {
                        let p2 = Concrete::star_polygon_with_edge(n2, d2, 1.0);
                        Concrete::duoprism(&p1, &p2)
                    }
                },
                format!(
                    "{}{}-{}{} duoprism",
                    n1,
                    if d1 > 1 {format!("/{}", d1)} else {"".to_string()},
                    n2,
                    if d2 > 1 {format!("/{}", d2)} else {"".to_string()}
                )
            ),

            // Loads a uniform polygonal antiprism prism.
            Self::AntiprismPrism(n, d) => (
                Concrete::uniform_antiprism(n, d).prism(),
                format!(
                    "{}{}-gonal antiprism prism",
                    n,
                    if d > 1 {format!("/{}", d)} else {"".to_string()}
                )
            ),

            // Loads a simplex with a given rank.
            Self::Simplex(rank) => (
                Concrete::simplex((rank + 1) as usize),
                format!("{}-simplex", rank)
            ),

            // Loads a hypercube with a given rank.
            Self::Hypercube(rank) => (
                Concrete::hypercube((rank + 1) as usize),
                format!("{}-cube", rank)
            ),

            // Loads an orthoplex with a given rank.
            Self::Orthoplex(rank) => (
                Concrete::orthoplex((rank + 1) as usize),
                format!("{}-orthoplex", rank)
            ),
        }
    }
}
